# Docker Course Syllabus - Part 1

## Containers â€“ What Are They and Why Do I Need Them When I Have a VM?

### Slide 1: Introduction to Containers
- **Definition**: A container is a lightweight, portable, and self-sufficient software package that includes everything needed to run an application.
- **Key Features**:
  - Isolated processes.
  - Shared OS kernel.
  - Lightweight compared to VMs.
- **Image Example**:
  ![Containers Overview](https://example.com/container-overview.png)

### Slide 2: Why Containers When We Have VMs?
- **Comparison**:
  - VMs: Heavyweight, include entire OS.
  - Containers: Lightweight, share host OS.
- **Advantages of Containers**:
  - Faster startup.
  - Reduced resource usage.
  - Portability across environments.
- **Diagram**:
  ![Containers vs VMs](https://example.com/containers-vs-vms.png)

### Slide 3: Real-World Benefits of Containers
- Faster application deployment.
- Easier scaling and testing.
- Environment consistency across development and production.

### Slide 4: Exercise
- Create a list of use cases where containers would be better than VMs.
- Discuss in groups: What challenges do containers solve in your workflow?

---

## Docker Architecture

### Slide 1: Core Components of Docker
- **Docker Engine**:
  - CLI (Command Line Interface).
  - REST API.
  - Docker Daemon.
- **Image Example**:
  ![Docker Engine](https://example.com/docker-engine.png)

### Slide 2: Docker Workflow
- **Steps**:
  - Build.
  - Ship.
  - Run.
- **Diagram**:
  ![Docker Workflow](https://example.com/docker-workflow.png)

### Slide 3: How Docker Runs Containers
- Uses cgroups and namespaces for isolation.
- Leverages union file systems for storage efficiency.
- Connects via network bridges.

### Slide 4: Exercise
- Draw the architecture of Docker.
- Explain the interaction between CLI, API, and Daemon in your own words.

---

## Building Docker Images with Dockerfile

### Slide 1: What is a Dockerfile?
- **Definition**: A text file that contains instructions to build a Docker image.
- **Key Instructions**:
  - `FROM`: Base image.
  - `RUN`: Execute commands.
  - `COPY`/`ADD`: Add files to the image.
- **Example Code**:
  ```dockerfile
  FROM python:3.9
  WORKDIR /app
  COPY . .
  RUN pip install -r requirements.txt
  CMD ["python", "app.py"]
  ```

### Slide 2: Steps to Build an Image
1. Write a Dockerfile.
2. Use `docker build` to create an image.
3. Run the container using `docker run`.

### Slide 3: Best Practices
- Use lightweight base images.
- Minimize layers.
- Use `.dockerignore` for sensitive files.

### Slide 4: Exercise
- Write a Dockerfile for a simple Node.js app.
- Build and run the container.

---

## Docker Hub & Registry

### Slide 1: Docker Hub Overview
- **Definition**: A cloud-based repository for Docker images.
- **Features**:
  - Public and private repositories.
  - Automated builds.
  - Versioning.
- **Image Example**:
  ![Docker Hub](https://example.com/docker-hub.png)

### Slide 2: Custom Registries
- **Options**:
  - Self-hosted (Harbor, Nexus).
  - Cloud services (AWS ECR, Azure Container Registry).
- **Advantages**:
  - Security.
  - Performance optimization.

### Slide 3: Push and Pull Workflow
- **Commands**:
  - Push: `docker push <repo/image>`.
  - Pull: `docker pull <repo/image>`.

### Slide 4: Exercise
- Push your first Docker image to Docker Hub.
- Pull an official image from Docker Hub and run it.

---

## Docker Networking

### Slide 1: Introduction to Docker Networking
- **Definition**: The way Docker containers communicate with each other and the outside world.
- **Network Types**:
  - Bridge.
  - Host.
  - Overlay.
  - None.
- **Image Example**:
  ![Docker Networking](https://example.com/docker-networking.png)

### Slide 2: Bridge Networks
- **Default network for containers**.
- Provides NATed access to the host.
- **Commands**:
  - `docker network ls`
  - `docker network inspect <network>`

### Slide 3: Custom Networks
- Create using `docker network create`.
- Allow inter-container communication.

### Slide 4: Exercise
- Create a custom network.
- Run two containers and verify they can ping each other.

---

## Docker Volumes

### Slide 1: What are Volumes?
- **Definition**: A mechanism to persist data generated by and used by Docker containers.
- **Types**:
  - Named volumes.
  - Bind mounts.
- **Advantages**:
  - Data persistence.
  - Shared data between containers.

### Slide 2: Managing Volumes
- **Commands**:
  - Create: `docker volume create <name>`.
  - List: `docker volume ls`.
  - Inspect: `docker volume inspect <name>`.

### Slide 3: Best Practices
- Use volumes for stateful applications.
- Avoid storing sensitive data directly.

### Slide 4: Exercise
- Create a container with a mounted volume.
- Verify data persistence after container restart.

---

## Docker Compose

### Slide 1: Introduction to Docker Compose
- **Definition**: A tool to define and run multi-container Docker applications.
- **Key Features**:
  - YAML configuration.
  - Multi-container orchestration.
  - Port and volume mapping.

### Slide 2: Writing a `docker-compose.yml`
- Example:
  ```yaml
  version: '3'
  services:
    web:
      image: nginx
      ports:
        - "8080:80"
    redis:
      image: redis
  ```

### Slide 3: Commands
- Start: `docker-compose up`
- Stop: `docker-compose down`
- List services: `docker-compose ps`

### Slide 4: Exercise
- Write a `docker-compose.yml` to start a web server and database.
- Use `docker-compose up` to bring the stack online.

---

## Docker as Our Local Development Environment

### Slide 1: Benefits of Using Docker Locally
- **Advantages**:
  - Consistent environment.
  - Easy dependency management.
  - Fast onboarding.

### Slide 2: Setting Up Docker for Development
- Use Docker Compose for multi-container setups.
- Mount local directories for live code editing.

### Slide 3: Real-World Example
- Example: Running a Python app with a database locally.
  ```yaml
  version: '3'
  services:
    app:
      image: python:3.9
      volumes:
        - .:/app
      command: python app.py
    db:
      image: postgres
  ```

### Slide 4: Exercise
- Create a development environment for your favorite language.
- Test hot-reloading with mounted volumes.

---

## Intro to K8S (Not Hands-On)

### Slide 1: What is Kubernetes?
- **Definition**: An open-source system for automating deployment, scaling, and management of containerized applications.
- **Components**:
  - Nodes.
  - Pods.
  - Services.
  - Deployments.

### Slide 2: Why Kubernetes?
- Advantages over plain Docker:
  - Scalability.
  - Self-healing.
  - Load balancing.

### Slide 3: Kubernetes Architecture
- **Diagram**:
  ![Kubernetes Architecture](https://example.com/k8s-architecture.png)

### Slide 4: Exercise
- Research and list five benefits of Kubernetes over Docker Compose.
- Discuss in groups how Kubernetes can improve CI/CD pipelines.

